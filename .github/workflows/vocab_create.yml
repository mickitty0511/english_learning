name: Vocabulary Card - Create

on:
  issues:
    types: [opened]

permissions:
  contents: write
  pull-requests: write
  issues: write
  statuses: write

jobs:
  create:
    if: contains(github.event.issue.labels.*.name, 'generate')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y fonts-dejavu-core jq
          python3 -m pip install --upgrade pip
          python3 -m pip install pillow requests

      - name: Parse
        id: parse
        env:
          ISSUE_EVENT_JSON: ${{ toJson(github.event) }}
        run: python3 .github/scripts/diff_lines.py "$ISSUE_EVENT_JSON"

      - name: Probe DashScope (HTTP code only)
        env:
          DASHSCOPE_API_KEY: ${{ secrets.DASHSCOPE_API_KEY }}
        run: |
          set -euo pipefail
          code=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer ${DASHSCOPE_API_KEY}" \
            -H "X-DashScope-Async: enable" \
            -H "Content-Type: application/json" \
            -d '{"model":"qwen-image-plus","input":{"prompt":"probe"},"parameters":{"size":"512*512","n":1}}' \
            https://dashscope-intl.aliyuncs.com/api/v1/services/aigc/text2image/image-synthesis)
          echo "DashScope probe: $code"
          [ "$code" = "200" ]

      - name: Generate cards
        env:
          WORD_DISPLAY: ${{ steps.parse.outputs.word_display }}
          WORD_SLUG: ${{ steps.parse.outputs.word_slug }}
          DASHSCOPE_API_KEY: ${{ secrets.DASHSCOPE_API_KEY }}
        run: |
          set -euo pipefail
          mkdir -p "src/${WORD_SLUG}"

          # Issue body ÊäΩÂá∫
          body=$(jq -r '.issue.body' <<< '${{ toJson(github.event) }}')

          # „Ç≥„Éº„Éâ„Éñ„É≠„ÉÉ„ÇØ„ÅÆ ``` „ÇíÂâ•„Åå„Åó„ÄÅÂÖàÈ†≠Á©∫ÁôΩ„ÇíË®±ÂÆπ
          clean_body=$(sed 's/```//g' <<< "$body" | sed 's/^[[:space:]]*//')

          # "1. ..." ÂΩ¢Âºè„ÅÆË°å„Å†„Åë„ÇíÊäΩÂá∫ÔºàÂå∫Âàá„Çä„ÅØ , „Åæ„Åü„ÅØ | „Å´‰∏°ÂØæÂøúÔºâ
          grep -E '^[0-9]+\.\s' <<< "$clean_body" > cme.txt || true

          # Ë°å„Åî„Å®„Å´Âé≥ÂØÜ„Éë„Éº„ÇπÔºö index / concept / meaning / example
          while IFS= read -r line; do
            if [[ "$line" =~ ^([0-9]+)\.\ +([^,|]+)[,|]\ +([^,|]+)[,|]\ +(.+)$ ]]; then
              idx="${BASH_REMATCH[1]}"
              concept="${BASH_REMATCH[2]}"
              meaning="${BASH_REMATCH[3]}"
              example="${BASH_REMATCH[4]}"

              echo "Parsed: idx=$idx, concept=$concept"

              python3 .github/scripts/generate_card.py \
                --api-key "$DASHSCOPE_API_KEY" \
                --word "$WORD_DISPLAY" \
                --index "$idx" \
                --concept "$concept" \
                --meaning "$meaning" \
                --example "$example" \
                --outdir "src/$WORD_SLUG"
            fi
          done < cme.txt

      # --- GPGÁΩ≤Âêç„ÇíÊúâÂäπÂåñÔºàSecrets„ÇíÂà©Áî®Ôºâ ---
      - name: Import GPG key for signing
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}
          git_user_signingkey: true
          git_commit_gpgsign: true

      - name: Commit and push
        run: |
          set -euo pipefail
          git config user.name  "${{ secrets.SIGNING_NAME }}"
          git config user.email "${{ secrets.SIGNING_EMAIL }}"
          # ÁîªÂÉè„Éª„É°„Çø„Éª„É¨„Éù„Éº„Éà„Çí‰∏∏„Åî„Å®„Çπ„ÉÜ„Éº„Ç∏„É≥„Ç∞Ôºàreports „ÅØÂæåÁ∂ö„ÅßÁîüÊàêÔºâ
          git add "src/${{ steps.parse.outputs.word_slug }}/" "reports/" || true
          git commit -m "feat(cards): create ${{ steps.parse.outputs.word_display }}" || echo "no changes"

      - name: Clean up temp file
        run: rm -f cme.txt || true

      - name: Create PR (always)
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ github.token }}
          commit-message: "feat(cards): ${{ steps.parse.outputs.word_display }}"
          branch: bot/vocab-${{ steps.parse.outputs.word_slug }}-${{ github.run_id }}
          title: "Vocab: ${{ steps.parse.outputs.word_display }}"
          body: |
            Auto-generated vocabulary card.
            - Word: ${{ steps.parse.outputs.word_display }}
            - Folder: src/${{ steps.parse.outputs.word_slug }}
          labels: bot,generate
          delete-branch: true
          clean: false

      # Approve PR automatically via GH CLI
      - name: Approve PR automatically via GH CLI
        if: steps.cpr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ secrets.APPROVER_TOKEN }}
          PR_NUMBER: ${{ steps.cpr.outputs.pull-request-number }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          gh pr review "$PR_NUMBER" --repo "$REPO" --approve --body "Auto-approved by machine user"

      # Auto-merge via GH CLI
      - name: Enable auto-merge via GH CLI (squash)
        if: steps.cpr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ steps.cpr.outputs.pull-request-number }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          gh pr merge "$PR_NUMBER" --repo "$REPO" --squash --auto

      - name: Log PR URL
        if: steps.cpr.outputs.pull-request-url != ''
        run: echo "PR = ${{ steps.cpr.outputs.pull-request-url }}"

      # ===== ‚ë† Structured image comment =====
      - name: Comment with structured sections
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const word = '${{ steps.parse.outputs.word_display }}';
            const slug = '${{ steps.parse.outputs.word_slug }}';
            const branch = `bot/vocab-${slug}-${{ github.run_id }}`;
            const dir = `src/${slug}`;
            const metaDir = path.join(dir, '.meta');
            const repoBase = `https://github.com/${context.repo.owner}/${context.repo.repo}/blob/${branch}/${dir}`;

            const LINE_RE = /^\s*(\d+)\.\s*([^,|]+)[,|]\s*([^,|]+)[,|]\s*(.+)$/;
            const log = (phase, payload) => {
              const safe = JSON.stringify(payload, (key, value) => {
                if (typeof value === 'string') {
                  return value.length > 120 ? value.slice(0, 117) + '...' : value;
                }
                return value;
              });
              console.log(`[comment-build] ${phase}: ${safe}`);
            };
            const parseIssue = (body = '') => {
              const map = new Map();
              for (const raw of body.split(/\r?\n/)) {
                const line = raw.trim();
                if (!line) continue;
                const match = line.match(LINE_RE);
                if (!match) continue;
                const [, idx, concept, meaning, example] = match;
                map.set(idx, {
                  concept: concept.trim(),
                  meaning: meaning.trim(),
                  example: example.trim()
                });
              }
              return map;
            };

            const issueEntries = parseIssue(context.payload.issue?.body || '');

            const files = fs.existsSync(dir)
              ? fs.readdirSync(dir).filter(f => f.endsWith('.jpg')).sort()
              : [];

            log('files-detected', { count: files.length, files });

            if (!files.length) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `‚ö†Ô∏è „Ç´„Éº„ÉâÁîªÂÉè„ÅåÁîüÊàê„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇIssueÊú¨Êñá„ÇíÁ¢∫Ë™ç„ÅóÂÜçÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`
              });
              return;
            }

            const sanitize = value => (value || '').toString().trim();
            const commentLines = ['## ' + word, ''];

            for (const file of files) {
              const [rawIdx, ...rest] = file.replace('.jpg', '').split('_');
              const idx = rawIdx || '';
              const conceptKey = rest.join('_');

              let concept = sanitize(process.env[`CONCEPT_${idx}`]);
              let meaning = sanitize(process.env[`MEANING_${idx}`]);
              let example = sanitize(process.env[`EXAMPLE_${idx}`]);

              const metaPath = path.join(metaDir, `${idx}_${conceptKey}.json`);
              if (fs.existsSync(metaPath)) {
                const meta = JSON.parse(fs.readFileSync(metaPath, 'utf8'));
                meaning = meaning || sanitize(meta.meaning);
                example = example || sanitize(meta.example);
                if (!concept && meta.original) {
                  concept = sanitize(meta.original);
                }
                if (!concept && meta.concept) {
                  concept = sanitize(meta.concept);
                }
                log('meta-loaded', { idx, metaPath, fromMeta: { concept, meaning, example } });
              } else {
                log('meta-missing', { idx, expected: metaPath });
              }

              if (!concept || !meaning || !example) {
                const fallback = issueEntries.get(idx);
                if (fallback) {
                  concept = concept || sanitize(fallback.concept);
                  meaning = meaning || sanitize(fallback.meaning);
                  example = example || sanitize(fallback.example);
                  log('issue-fallback', { idx, concept, meaning, example });
                }
              }

              if (!concept) {
                concept = sanitize(conceptKey.replace(/-/g, ' '));
              }
              if (!meaning) meaning = 'N/A';
              if (!example) example = 'N/A';

              log('final-card', { idx, concept, meaning, example, file });

              commentLines.push(
                `### ${idx}. ${concept}`,
                `- Meaning: ${meaning}`,
                `- Example: ${example}`,
                '',
                `![${concept}](${repoBase}/${encodeURIComponent(file)}?raw=true)`,
                ''
              );
            }

            const body = commentLines.join('\n').replace(/\n{3,}/g, '\n\n').trimEnd();

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });

      # ‚ë° „Çπ„Ç≥„Ç¢„É¨„Éù„Éº„ÉàÁîüÊàêÔºã„Ç≥„É°„É≥„Éà
      - name: Generate Legibility Report
        shell: bash
        run: >
          python3 .github/scripts/collect_legibility.py
          --word "${{ steps.parse.outputs.word_display }}"
          --slug "${{ steps.parse.outputs.word_slug }}"

      - name: Comment Legibility Report
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const word = '${{ steps.parse.outputs.word_display }}';
            const slug = '${{ steps.parse.outputs.word_slug }}';
            const reportPath = path.join('reports', 'layout_scores', `${slug}.csv`);
            const branch = `bot/vocab-${slug}-${{ github.run_id }}`;
            const repoBase = `https://github.com/${context.repo.owner}/${context.repo.repo}/blob/${branch}/src/${slug}`;

            if (!fs.existsSync(reportPath)) {
              console.log("No report file found, skipping.");
              return;
            }

            const lines = fs.readFileSync(reportPath, 'utf8')
              .trim()
              .split(/\r?\n/)
              .slice(1)  // skip header
              .filter(Boolean);

            const clean = s => s.replace(/\r/g, '').trim();

            const md = [
              `üîé **Legibility Report for ${word}**`,
              '',
              '| index | concept | score | status | preview |',
              '|-------|----------|--------|---------|----------|',
              ...lines.map(l => {
                const [i,c,s,st,img] = l.split(',').map(clean);
                const safeImg = encodeURIComponent((img || '').replace(/[\r\n]+/g, ''));
                return `| ${i} | ${c} | ${s} | ${st} | ![img](${repoBase}/${safeImg}?raw=true) |`;
              })
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: md
            });
