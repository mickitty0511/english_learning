name: Vocabulary Card - Edit
on:
  issues:
    types: [edited]

permissions:
  contents: write
  pull-requests: write
  issues: write
  statuses: write

jobs:
  edit:
    if: contains(github.event.issue.labels.*.name, 'generate')
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup environment
        run: |
          sudo apt-get update
          sudo apt-get install -y fonts-dejavu-core
          python3 -m pip install pillow requests jq

      # ===== Parse changed lines =====
      - name: Parse changed lines
        id: diff
        env:
          ISSUE_EVENT_JSON: ${{ toJson(github.event) }}
        run: python3 .github/scripts/diff_lines.py "$ISSUE_EVENT_JSON"

      # ===== Re-generate changed cards only =====
      - name: Re-generate changed cards
        if: steps.diff.outputs.changed_indices != ''
        env:
          WORD_DISPLAY: ${{ steps.diff.outputs.word_display }}
          WORD_SLUG: ${{ steps.diff.outputs.word_slug }}
          CHANGED: ${{ steps.diff.outputs.changed_indices }}
          DASHSCOPE_API_KEY: ${{ secrets.DASHSCOPE_API_KEY }}
        run: |
          mkdir -p "src/${WORD_SLUG}"
          IFS=',' read -ra IDX <<< "$CHANGED"
          for i in "${IDX[@]}"; do
            concept_var="CONCEPT_${i}"
            meaning_var="MEANING_${i}"
            example_var="EXAMPLE_${i}"
            concept="${!concept_var}"
            meaning="${!meaning_var}"
            example="${!example_var}"
            echo "Re-generating $i. $concept"
            python3 .github/scripts/generate_card.py \
              --api-key "$DASHSCOPE_API_KEY" \
              --word "$WORD_DISPLAY" \
              --index "$i" \
              --concept "$concept" \
              --meaning "$meaning" \
              --example "$example" \
              --outdir "src/$WORD_SLUG"
          done
      
      # --- GPGç½²åã‚’æœ‰åŠ¹åŒ–ï¼ˆSecretsã‚’åˆ©ç”¨ï¼‰ ---
      - name: Import GPG key for signing
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}
          git_user_signingkey: true
          git_commit_gpgsign: true

      # ===== Commit and push =====
      - name: Commit and push updated cards
        run: |
          git config user.name  "${{ secrets.SIGNING_NAME }}"
          git config user.email "${{ secrets.SIGNING_EMAIL }}"
          git add "src/${{ steps.diff.outputs.word_slug }}/"
          git commit -m "fix(cards): update ${{ steps.diff.outputs.word_display }}" || echo "no changes"
        
      - name: Clean up temp commit file
        run: rm -f cme.txt || true

      - name: Create PR (always)
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ github.token }}
          commit-message: "feat(cards): ${{ steps.parse.outputs.word_display }}"
          branch: bot/vocab-${{ steps.parse.outputs.word_slug }}-${{ github.run_id }}
          title: "Vocab: ${{ steps.parse.outputs.word_display }}"
          body: |
            Auto-generated vocabulary card.
            - Word: ${{ steps.parse.outputs.word_display }}
            - Folder: src/${{ steps.parse.outputs.word_slug }}
          labels: bot,generate
          delete-branch: true

      # Approve PR automatically via GH CLI
      - name: Approve PR automatically via GH CLI
        if: steps.cpr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ secrets.APPROVER_TOKEN }}
          PR_NUMBER: ${{ steps.cpr.outputs.pull-request-number }}
          REPO: ${{ github.repository }}
        run: |
          set -euxo pipefail
          gh pr review "$PR_NUMBER" --repo "$REPO" --approve --body "Auto-approved by machine user"

      # Auto-merge via GH CLI
      - name: Enable auto-merge via GH CLI (squash)
        if: steps.cpr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ steps.cpr.outputs.pull-request-number }}
          REPO: ${{ github.repository }}
        run: |
          set -euxo pipefail
          gh pr merge "$PR_NUMBER" --repo "$REPO" --squash --auto

      - name: Log PR URL
        if: steps.cpr.outputs.pull-request-url != ''
        run: echo "PR = ${{ steps.cpr.outputs.pull-request-url }}"

      # ===== â‘  Structured image comment =====
      - name: Comment with structured sections
        uses: actions/github-script@v7
        with:
          script: |
            const word = '${{ steps.parse.outputs.word_display || steps.diff.outputs.word_display }}';
            const slug = '${{ steps.parse.outputs.word_slug    || steps.diff.outputs.word_slug }}';

            // æ—¢å­˜ã®ã‚°ãƒ­ãƒ¼ãƒãƒ« context ã‚’ãã®ã¾ã¾ä½¿ã†
            const defaultBranch = context.payload.repository.default_branch || 'main';
            const repoBase = `https://github.com/${context.repo.owner}/${context.repo.repo}/blob/${defaultBranch}/src/${slug}`;

            const fs = require('fs');
            const path = require('path');
            const dir = `src/${slug}`;
            const metaDir = `${dir}/.meta`;
            let lines = [];
            lines.push(`## ${word}`, '');

            const files = fs.existsSync(dir)
              ? fs.readdirSync(dir).filter(f => f.endsWith('.jpg')).sort()
              : [];

            for (const f of files) {
              const idx = f.split('_')[0];
              const concept = f.split('_').slice(1).join('_').replace('.jpg','');
              let meaning=''; let example='';
              const metaPath = `${metaDir}/${idx}_${concept}.json`;
              if (fs.existsSync(metaPath)) {
                const meta = JSON.parse(fs.readFileSync(metaPath,'utf8'));
                meaning = meta.meaning || '';
                example = meta.example || '';
              }
              lines.push(
                `### ${idx}. ${concept}`,
                `- Meaning: ${meaning}`,
                `- Example: ${example}`,
                '',
                `![${f}](${repoBase}/${encodeURIComponent(f)}?raw=true)`,
                ''
              );
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: lines.join('\n')
            });

      # ===== â‘¡ Generate legibility report =====
      - name: Generate Legibility Report
        shell: bash
        run: >
          python3 .github/scripts/collect_legibility.py
          --word "${{ steps.parse.outputs.word_display || steps.diff.outputs.word_display }}"
          --slug "${{ steps.parse.outputs.word_slug    || steps.diff.outputs.word_slug }}"

      # ===== â‘¢ Comment legibility report =====
      - name: Comment Legibility Report
        uses: actions/github-script@v7
        with:
          script: |
            const word = '${{ steps.parse.outputs.word_display || steps.diff.outputs.word_display }}';
            const slug = '${{ steps.parse.outputs.word_slug    || steps.diff.outputs.word_slug }}';

            const fs = require('fs');
            const path = require('path');
            const reportPath = path.join('reports/layout_scores', `${slug}.csv`);

            const defaultBranch = context.payload.repository.default_branch || 'main';
            const repoBase = `https://github.com/${context.repo.owner}/${context.repo.repo}/blob/${defaultBranch}/src/${slug}`;

            if (!fs.existsSync(reportPath)) {
              console.log("No report file found, skipping.");
              return;
            }

            // ã“ã“ã‚’ robust ã«ï¼š\r?\n ã§åˆ†å‰²ã—ã€å„ã‚»ãƒ«ã‹ã‚‰ \r ã‚’é™¤å»
            const lines = fs.readFileSync(reportPath, 'utf8')
              .trim()
              .split(/\r?\n/)
              .slice(1)  // skip header
              .filter(Boolean);

            const clean = s => s.replace(/\r/g, '').trim();

            const md = [
              `ğŸ” **Legibility Report for ${word}**`,
              '',
              '| index | concept | score | status | preview |',
              '|-------|----------|--------|---------|----------|',
              ...lines.map(l => {
                const [i,c,s,st,img] = l.split(',').map(clean);
                // å¿µã®ãŸã‚ãƒ•ã‚¡ã‚¤ãƒ«åã®æ”¹è¡Œç³»ã¯å…¨é™¤å»
                const safeImg = encodeURIComponent(img.replace(/[\r\n]+/g, ''));
                return `| ${i} | ${c} | ${s} | ${st} | ![img](${repoBase}/${safeImg}?raw=true) |`;
              })
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: md
            });
